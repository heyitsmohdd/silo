// Prisma Schema for The Academic Vault
// Strict Multi-Tenant Batch Isolation: (year, branch)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum Role {
  SUPER_ADMIN
  PROFESSOR
  STUDENT
}

enum NotificationType {
  REPLY
  UPVOTE
  MENTION
}

// ============================================================================
// USER MODEL
// ============================================================================

model User {
  id        String   @id @default(uuid()) @db.Uuid
  email     String   @unique
  password  String   // bcrypt hashed
  
  // Username (can be changed once every 6 months)
  username  String?  @unique
  lastUsernameChange DateTime? @map("last_username_change")
  
  // Batch Context
  year      Int
  branch    String   // e.g., "CS", "Mech", "ECE"
  
  // RBAC
  role      Role     @default(STUDENT)
  
  // Metadata
  firstName String?
  lastName  String?
  
  // Soft Delete
  isDeleted Boolean  @default(false) @map("is_deleted")
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relations
  notes     Note[]
  messages  Message[]
  questions Question[]
  answers   Answer[]
  reactions Reaction[]
  
  // Notification Relations
  notifications      Notification[] @relation("UserNotifications")
  triggeredNotifications Notification[] @relation("ActorNotifications")
  
  @@index([year, branch])
  @@index([email])
  @@map("users")
}

// ============================================================================
// ALLOWED EMAIL MODEL (VIP Whitelist)
// ============================================================================

model AllowedEmail {
  id        String   @id @default(uuid()) @db.Uuid
  email     String   @unique
  addedBy   String?  @map("added_by") // Who added this email (optional)
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  
  @@index([email])
  @@map("allowed_emails")
}


// ============================================================================
// NOTE MODEL (Academic Content)
// ============================================================================

model Note {
  id        String   @id @default(uuid()) @db.Uuid
  
  // Content
  title     String
  content   String   @db.Text
  subject   String
  
  // Batch Context (Enforced Isolation)
  year      Int
  branch    String
  
  // Ownership
  authorId  String   @map("author_id") @db.Uuid
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // File Metadata (Optional)
  fileUrl   String?  @map("file_url")
  fileType  String?  @map("file_type")
  
  // Soft Delete
  isDeleted Boolean  @default(false) @map("is_deleted")
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@index([year, branch])
  @@index([subject])
  @@index([authorId])
  @@map("notes")
}

// ============================================================================
// MESSAGE MODEL (Real-time Chat)
// ============================================================================

model Message {
  id        String   @id @default(uuid()) @db.Uuid
  
  // Content
  content   String   @db.Text
  
  // Chat Room Identifier
  roomId    String   @map("room_id")
  
  // Batch Context (Enforced Isolation)
  year      Int
  branch    String
  
  // Anonymous Sender Tracking
  // Students are anonymous to each other, but not to SUPER_ADMIN
  senderId  String   @map("sender_id") @db.Uuid
  sender    User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  
  // Soft Delete
  isDeleted Boolean  @default(false) @map("is_deleted")
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@index([year, branch, roomId])
  @@index([senderId])
  @@map("messages")
}

// ============================================================================
// QUESTION MODEL (Q&A Feature)
// ============================================================================

model Question {
  id        String   @id @default(uuid()) @db.Uuid
  
  // Content
  title     String
  content   String   @db.Text
  tags      String[] // Array of tags for categorization
  
  // New Fields
  category  Category @default(ACADEMIC)
  
  // Batch Context (Enforced Isolation)
  year      Int
  branch    String
  
  // Ownership
  authorId  String   @map("author_id") @db.Uuid
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Voting (Legacy - Kept for backward compatibility)
  upvotes   Int      @default(0)
  downvotes Int      @default(0)
  
  // Reactions (New System)
  reactions Reaction[]
  


  // Best Answer Selection (One-to-One)
  bestAnswerId String? @unique @map("best_answer_id") @db.Uuid
  bestAnswer   Answer? @relation("BestAnswer", fields: [bestAnswerId], references: [id], onDelete: SetNull)
  
  // Relations
  answers   Answer[] @relation("QuestionAnswers")
  
  // Soft Delete
  isDeleted Boolean  @default(false) @map("is_deleted")
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@index([year, branch])
  @@index([authorId])
  @@index([bestAnswerId])
  @@map("questions")
}

// ============================================================================
// REACTION MODEL (Granular feedback)
// ============================================================================

model Reaction {
  id         String   @id @default(uuid()) @db.Uuid
  type       String   // e.g., "üî•", "üíÄ", "‚ù§Ô∏è", "üí©"
  
  // User who reacted
  userId     String   @map("user_id") @db.Uuid
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Target Question
  questionId String   @map("question_id") @db.Uuid
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  // TODO: Add support for Answer reactions if needed later

  @@unique([userId, questionId]) // User can only react ONCE per post (reaction type may change)
  @@index([questionId])
  @@index([userId])
  @@map("reactions")
}

// ============================================================================
// CATEGORY ENUM
// ============================================================================

enum Category {
  ACADEMIC
  GOSSIP
  RANT
  CONFESSION
  OTHER
}

// ============================================================================
// ANSWER MODEL (Q&A Feature)
// ============================================================================

model Answer {
  id        String   @id @default(uuid()) @db.Uuid
  
  // Content
  content   String   @db.Text
  
  // Question Relation
  questionId String  @map("question_id") @db.Uuid
  question   Question @relation("QuestionAnswers", fields: [questionId], references: [id], onDelete: Cascade)
  
  // Batch Context (Enforced Isolation)
  year      Int
  branch    String
  
  // Ownership
  authorId  String   @map("author_id") @db.Uuid
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Voting
  upvotes   Int      @default(0)
  downvotes Int      @default(0)
  
  // Best Answer Back-Relation
  bestQuestionId String?   @unique @map("best_question_id") @db.Uuid
  bestQuestion   Question? @relation("BestAnswer")
  
  // Threading (Self-Relation)
  parentId  String?  @map("parent_id") @db.Uuid
  parent    Answer?  @relation("AnswerReplies", fields: [parentId], references: [id])
  children  Answer[] @relation("AnswerReplies")
  
  // Soft Delete
  isDeleted Boolean  @default(false) @map("is_deleted")
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@index([year, branch])
  @@index([questionId])
  @@index([authorId])
  @@index([bestQuestionId])
  @@map("answers")
}

// ============================================================================
// ACCESS REQUEST MODEL (Waitlist)
// ============================================================================

model AccessRequest {
  id        String   @id @default(uuid()) @db.Uuid
  email     String   @unique
  status    String   @default("PENDING") // Options: PENDING, APPROVED, REJECTED
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  @@map("access_requests")
}

// ============================================================================
// NOTIFICATION MODEL
// ============================================================================

model Notification {
  id         String   @id @default(cuid())
  userId     String   @db.Uuid // Recipient
  actorId    String   @db.Uuid // Person who triggered the notification
  type       NotificationType
  message    String
  resourceId String?  // Question/Answer ID
  isRead     Boolean  @default(false) @map("is_read")
  
  // Timestamps
  createdAt  DateTime @default(now()) @map("created_at")
  
  // Relations
  user  User @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  actor User @relation("ActorNotifications", fields: [actorId], references: [id], onDelete: Cascade)
  
  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}
